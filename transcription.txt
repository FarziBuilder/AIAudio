Welcome everybody to part 5 of this YMFC 3D video session. In this video I'll explain the workings of a PID controller and how to implement it into the Arduino code of our multicopter flight controller. But before we start I would like to show you something. With this setup I can show you the thrust of a multicopter motor in relation to the battery voltage. Now with a full battery the thrust is approximately 250 grams. And as you can see when the battery voltage drops the thrust is significantly reduced. And at the end we'll only get 170 grams of thrust. Now this is an important issue to keep in mind. Let's take a look at the basic principle of a PID controller. Simply put it, it's only goal is to keep the inputs of the gyro angular rates the same as the inputs of the receiver. For example if the pilot wants no movements, the gyro's angular rate also needs to be zero. To do this the PID controller calculates the corrections for the four motors that are needed to keep the multicopter level. The PID algorithm can be written like this. This is very interesting, especially this thingy here and this part over here. But don't get intimidated by it. Translating the algorithm to Arduino code only takes four lines as shown here. But we get to that later. PID stands for proportional, integral and derivative. These three parts are calculated simultaneously and combined to one output signal. If we look at a proportional part, it simply calculates the difference between the gyro and the receiver and multiplies it with the gain. So if the pilot wants zero movements, the receiver output is zero degrees per second. When the gyro senses 10 degrees per second of movement, the output of the proportional controller is 10 if the gain is set to 1. The response of the output can be influenced by changing the gain. The integral controller calculates the difference between the gyro and the receiver and multiplies it with the gain. The result is added to the previous output of the integral controller. So if the receiver output is zero and the gyro senses 10 degrees per second of movement, the output is 10 when the gain is set to 1. The next time the output will be 20, after that 3 and so on. The derivative controller calculates the current difference between the gyro and the receiver. The difference from the previous calculation is subtracted from the current difference and is multiplied with the gain. So when a receiver is set to zero and the gyro's angular rate is 10 degrees per second, the current difference is 10. Now let's say that the previous difference also was 10, making the output of the derivative controller zero. This is an excel sheet that I made to visualize the separate controller outputs for just one axis. Now let's say the roll axis. In the top the three gain settings are shown. To keep it simple I set them to 1. In the first column you see the loop time. Now the refresh rate is 250 Hz so the time is a multiple of 4. So every line represents a controller loop. The second column shows the receiver input. In this case they're all zero because the pilot doesn't want the multicopter to move. This column shows the gyro angular rate in degrees per second. To simulate turbulence I just throwed in some numbers. The error column is the difference between the gyro and the receiver. Because the receiver is zero, the error is the same as the gyro angular rate. Next is the P-controller output. As explained this is just the error multiplied by the gain. And if we look at the graphics you'll see that the output is exactly the same as the error because the gain is set to 1. Now the outcome increases when I change the gain to 2. Now I build a test stand so I can show the results of just the P-controller. Now with only the P-controller the multicopter keeps oscillating around the center position. Now there is almost no friction so the controller keeps overcompensating itself. The output of the I-controller is the sum of the errors multiplied by the gain. So when the error is positive, the output of the I-controller increases. When the output of the gyro is negative, the output decreases. And as you can see in this example the sum of the positive errors are the same as the negative errors, bringing the output of the I-controller back to zero. When I show only the I-controller on the test stand, you can see that it overcompensates just like the P-controller. Only the oscillation is much slower because the output slowly increases. But it keeps overcompensating. When I keep it level at the start, there is no controller output. When I pull it down, it starts to fight me until it is back in the same position as it was before. Now this is because the controller output only changes when there is angular motion. When there is no angular motion, the controller output stays the same. The D-controller is somewhat different because it only reacts on a change of error. As you can see in the graphics, it only reacts a few times at the start of an angular motion. Now this might not look interesting, but this controller is very important for our multicopter. Because there is no friction, the multicopter easily overcompensates as we saw before. When set up correctly, the D-controller gives just enough, so to say, friction to prevent the other controllers from overcompensating. The results on the test stand are pretty funny to see. When I do nothing, it just sits there. When I start moving the arm, it fights the start. But when it is moving, it keeps moving because it doesn't want to slow down. Now you could simply say that the D-controller just hates a change in angular motion. Before we implement the PID controller into the Arduino code, I'll show you some other parts of the code that we will need for the final program. In the beginning of this video I showed you that we need to compensate the voltage drop of the battery. With the voltage divisor that I showed you in the first video, we get a 5 volt input on the analog input 0 with a full battery. In the setup routine, this line reads the analog input and calculates it to a readable value. When the program is running, we use a complementary filter to reduce noise. Now that we have our battery voltage, it is possible to turn on the LED if the battery voltage gets too low. Now all these parts are well commented, so I don't explain them in detail. At the top of the program, the PID gain settings are adjustable. Because we don't want the controller to go completely crazy, we limit the maximum output. In this case, the maximum output is plus or minus 400. As discussed, the gyro and receiver inputs are in degrees per second. In the manual of the gyro, we find that 1 bit represents 17.5 millidegrees per second. This is when we use a 500 degrees per second full scale. Because we need degree per second, we have to divide the gyro roll output by 57.14286. To get better results, we use a complementary filter to reduce some noise from the gyro signals. To transfer receiver inputs to degrees per second is a little bit different. Not everybody flies with the same roll and pitch rate. First we set the roll setpoint to 0. The receiver input fluctuates a little, so we need a little deadband. This prevents that the fluctuations of the receiver signals order the PID controller to do something. So from 1492 to 1508, the roll setpoint is 0. By dividing the receiver signals by 3, you get an approximate roll rate of 164 degrees per second. When you need faster roll rates, you need to reduce the 3.0. Now this is the subroutine where the magic happens. For now, I'm only showing the PID roll controller because the pitch and jaw controllers are the same. In the first line, the error between the gyro and the receiver is calculated. The second line is the eye controller. It multiplies the error with the gain and adds it to the PID eye mem roll variable. To prevent the eye controller from going out of control, we need to limit the output to the same output limit as set at the top of the program. After this, the complete PID output is calculated. The P gain is multiplied with the error and the D gain is multiplied with the difference between the current error and the previous error. Again, the controller is limited with these two lines because the P or D controller may cause some extreme outputs. And last but not least, the current error is saved for the next calculation. Now I will show you the basic steps on how to set up the PID settings of this particular multicopter controller. If you are lucky, this might also work on other flight controllers. But my main goal is to set up the YMSC 3D flight controller. Before you start, balance the motors and props to get the best results. You can use the program that I wrote for part 4 of this video session. Now before we start, we set a P gain of 1 for every gain. Hold the multicopter firmly in your hand and increase the throttle. Now you can feel if the controllers correct the multicopter in the right directions. If this is not the case, check the directions of the gyro with the program that I made for part 3. When the corrections are correct, set all the P gains back to 0. For now, we set a P gain of 3 and a I gain of 0.02 for the yaw. This basic setup will prevent the multicopter from yawing when we try to fly it. You can raise these settings later on. Setting a D gain for the yaw is not necessary because the yaw has much drag from the props. Now in contrast to others, I always begin with the D controller. We set the multicopter on a carpet or grass and raise the throttle up to the point it almost starts to hover. Increase the D gain up to the point that it becomes restless. Lower the D gain until it runs smooth again. On my multicopter this is 20. Then lower it again with 25% giving me a final setting of 15. Now start increasing the P gain in steps of 0.2. With a decent P gain you should be able to fly the multicopter. Just keep it nice and low and increase the P gain until it starts to overcompensate. Lower this P gain by 50% and keep this as your basic P gain setting, giving me a final setting of 1.3. Now you can start increasing the I gain in steps of 0.01. You will notice that the quad becomes more and more stable. Keep increasing the I gain until it starts to oscillate slowly. When this happens, lower the I gain by 50% and keep this as your basic setting, giving me a value of 0.05. Now increase the P gain again up to the point of fast oscillation. Take it back a few points and you have a good and stable multicopter. You can now start experimenting with the gains to get the optimal flight performance for your own setup. And this brings us to the end of this video. In the next part I'll show you the last bits and pieces and you can download the final Arduino program. If you have any questions, just leave them in the comments below and take the time to give this video a thumbs up if it was useful to you. Thank you for watching and see you next time.
